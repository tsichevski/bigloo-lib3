@node    cgen, afile, time, Bigloo Common Library
@section cgen - bigloo preprocessor

This section describes @code{cgen} -- the utility for creating bigloo
interfaces to C libraries.

@c ==================================================================
@subsection What is it for?

@code{cgen} allows you to create wrappers for external C functions and
external C types, such as structures, enums, bit fields and opaque
pointers.

@code{cgen} comes to you with @code{bigloo-lib} in @code{common/}
subdirectory. It should be automatically created before the creation of
any of @code{bigloo-lib} libraries. All the external C interfaces in
@code{bigloo-lib} are built with help of @code{cgen}.

@c ==================================================================
@subsection Why not bigloo foreign interface?

In course of evaluation of the foreign interface, I found it not always
suitable for the following reasons :

@itemize
@item
Too much code is usually auto-generated for every C declaration. Though
most of generated functions are declared as @code{inline}, their body is
copied into every module that uses it.

@item
The way the foreign types are supported is compiled into the Bigloo
compiler. You cannot change a bit in it without rebuilding Bigloo
executable. Even more, Bigloo documentation does not describes, how to
rebuild Bigloo if you change the Bigloo sources. @code{cgen} is, on the
other hand, quite simple and open-ended. It is not hard to change it
without risk to broke the whole compiler.

@item
The output of @code{cgen} is readable scheme text. When something goes
not as expected, you can easily check that's going on. Bigloo, in its
turn, does similar thing while compiling the @code{foreign} and
@code{extern} module clauses, i.e. it creates and compiles the low-level
scheme type expressions, but it never reveals the intermediate code to
the programmer.
@end itemize

@code{cgen} was developed in hope to achieve the following goals:

@itemize @minus

@item
Get more flexible control over that stuff has to be build and that has
not. For example, @code{cgen} creates write accessor for C structure
slots only if you specify that directly.

@item
Create more natural interfaces to C enums -- enum values can be taken as
arguments and returned by procedures as scheme symbols. Bigloo creates
the procedure for each enum value.

@item
Write interfaces to bit fields. @code{cgen} lets bit fields be presented
in scheme in form of lists of symbols.

@item
Support of C null pointers. The null pointers are converted to scheme
@code{#f} value.

@item
Write @code{GTK+} interface @ref{GTK+} compatible with @code{guile-gtk}
(@url{http://www.gtk.org}). Using the interface specifications from
@code{guile-gtk} saved me much work. The main idea and specification
file format came from @code{guile-gtk} also.

@item
Create first-class Bigloo procedures/ The procedures generated by
@code{cgen} are exported automatically, they may form bigloo library,
and may be visible in interpreter.

@item
Debug the auto-generated text: temporary insert printing commands, use
Bigloo debugger etc..
@end itemize

On the other hand, Bigloo has excellent capabilities of creating any new
types, using the @code{type} and @code{coerce} statements in module
declaration. The only bad thing with Bigloo type scheme is that it is
absolutely undocumented (though the documented @code{extern type}
interface is based upon that low-level layer).

@code{cgen} work is based upon these capabilities and it is alternative
to Bigloo @code{foreign} interface.

@c ==================================================================
@subsection  How does it works

@code{cgen} is a preprocessor for bigloo scheme code. It takes one or
more files with C interface specification as input and produces the
readable scheme file on output. The specification itself is bigloo
scheme text with some special constructs. As result of processing this
constructs the new procedures and bigloo module declarations are
created. All scheme expressions, that @code{cgen} does not recognize,
are printed back into output with no changes.

By convention, all the @code{cgen} input files have extension
@code{.defs} in @code{bigloo-lib}, you may use it as @code{cgen} usage
examples.

@c ==================================================================
@subsection cgen command line

Typically @code{cgen} is used in this form:

@example
cgen -o <outfile> file1 [file2] ...
@end example

The other options are:

@table @r

@item @code{-o <filename>}
Set the name of output file. @code{cgen} uses @code{current-error-port}
if this option is not used.

@item @code{-I <path>}
Add the path to path list where @code{cgen} looks for input files. This
option may occur more than once.

@item @code{-e <expr>}
Eval scheme expression. The side effects of the
evaluation may be used in @code{@@if} cgen directive to conditionally
process code.

@item @code{-v <number>}
Set the verbosity level. Any positive number causes some additional
information to be printed to @code{current-error-port}.

@item @code{--version}
@code{cgen} prints its version info and exits

@item @code{--help}
@code{cgen} prints its usage information and exits

@end table

The better way to learn @code{cgen} is to compile example code listed
below and explore the output of @code{cgen}.
@c ==================================================================
@subsection Name conversions

@subsubsection Defining a type names

Among other things, @code{cgen} creates new bigloo type
definitions. Each type definition requires knowing of two names: C
name, i.e. the name which will be used for underlaying C object, and
scheme name, which will be used in scheme code.

This names might be derived from either symbol, string or list of
exactly two elements.

If it a two-element list, then the first list element (case-sensitive
symbol) is used as the scheme type name , and the second list
element(string or case-sensitive symbol) as the C type name.

If it is a symbol, then it is (case-sensitive) converted to string and
used as described below.

If it is a string, then both type names derived from it:

The @code{"*"} string is appended to it, and the resulting string is
used as C type name (for example, @code{"GtkButton"}).

The corresponding scheme type name is created from C type name (without
an asterisk) using the following translation:

@table @minus
@item
The minus sign is inserted between the two adjacent letters of different
case, both letters are downcased. For example, the @code{GtkButton} is
converted to @code{gtk-button}, the @code{theABCDcode} becomes
@code{the-abcd-code}.

@item
All underscores are replaced by minuses, for example,
@code{gtk_window_new} is converted to @code{gtk-window-new}.

@end table

@subsubsection Defining names of an accessor

@code{cgen} allows you to automatically create a set of object
accessors. The specification provides two names: a C type name and a C
slot name. Then the names of each accessor are constructed using the
following rules:

@table @minus
@item
The object type name is converted as described above (for example,
@code{GtkButton} is converted to @code{gtk-button}), producing a scheme
object type name;

@item
The slot type name is converted as described above (for example,
@code{GtkButton} is converted to @code{gtk-button}), producing a scheme
slot type name;

@item
The slot name is converted as described above (for example,
@code{context_id} is converted to @code{context-id}), producing a scheme
slot name;

@item
The scheme name of an accessor is a concatenation of scheme object type
name with a scheme slot name suffix provided, delimited by a minus
sign. For example, the procedure reading the integer slot named
@code{context_id} of a structure named @code{GtkStatusbarMsg} will have
a prototype:

@example
(gtk-statusbar-msg-context-id::int o::gtk-statusbar-msg)
@end example

@end table

@c ==================================================================
@subsection Directives

Here are the @code{cgen} directives (in alphabetic order):

@deffn {cgen directive} define-accessors type field-list
Add accessors to an existing type defined by @code{define-object}. The
@var{type} argument is the scheme type name of the corresponding
type. The field list format is that of @var{field} format of
@code{define-object} directive.
@end deffn

@deffn {cgen directive} define-boxed names #!rest directives
Currently same as @code{define-object} directive.
@end deffn

@deffn {cgen directive} define-enum names . enum
@deffnx {cgen directive} define-enum-extended names . enum

Creates the new enumeration type. It takes the following arguments:

@table @r
@item @code{names}
The first argument @var{names} defines the type name (See "Defining a
type names" above").

@item @code{enums}

The remaining @code{enums} arguments must be two-element lists,
each list representing the elements of the enumeration. The first
element of each list (symbol, case-insensitive) is the scheme name of
the enum, the second (string or case-sensitive symbol) is used as C name
of enum element.

@end table

Each @code{define-enum} directive causes the following things to happen:

@table @r
@item
The new bigloo type is created with predicate and all the coercions necessary.

@item
The addition conversion that coerces enum element symbolic name to enum
element value
@end table

Examples:

@code{define-enum-extended} is the same as enum, but the corresponding
integer enum values may be used instead of symbol to present the enum
values.

@end deffn

@deffn {cgen directive} define-flags
@end deffn

@deffn {cgen directive} define-func namedef return-spec proto

Introduce a new interface to a C function.

Example:
@example
(define-func gtk_window_get_title string((GtkWindow window)))
@end example

The @var{namedef} argument defines the C (@code{gtk_window_get_title})
and scheme (@code{gtk-window-get-title}) names of interfaced
procedure. The @var{return-spec} defines C and scheme return types. The
@var{proto} argument is a list of the function argument descriptions.

The following directives all define interface to the same C procedures:

@example
(define-func gtk_window_get_title string ((GtkWindow window)))

;; same as above, but the Scheme name of the procedure is now explicitly
;; defined as `get-title' instead of automatically generated
;; `gtk-window-get-title'
(define-func (get-title gtk_window_get_title) string
  ((GtkWindow window)))

;; same as previous, but the C return type is `const char*' instead of
;; automatically generated `char *'
(define-func (get-title gtk_window_get_title)
  (string "const char*")
  ((GtkWindow window)))

;; same as previous, but the argument name is omitted
(define-func (get-title gtk_window_get_title)
  (string "const char*")
  ((GtkWindow)))

@end example

@end deffn

@deffn {cgen directive} define-object

The syntax of the @code{define-object} declaration is:

@flushleft
<define-object> @expansion{} @code{(} @code{define-object}
        <names>
        @code{(} <ancestor-list> @code{)}
        <directives>? @code{)}
<directives> @expansion{} <free-directive> |
        <copy-directive> |
        <size-directive> |
        <conversion-directive> |
        <fields-directive> |
        <false-directive>

<fields-directive> @expansion{} @code{(fields } <field-decl>+ @code{)}
<false-directive> @expansion{} @code{(false } <value-list> @code{)} | @code{(false)}
<free-directive> @expansion{} @code{(free ...)}
<copy-directive> @expansion{} @code{(copy ...)}
<size-directive> @expansion{} @code{(size ...)}
<conversion-directive> @expansion{} @code{(conversion ...)}
@end flushleft

The @code{define-object} directive is used to introduce a new object
type. Usually objects of that new type wrap pointers to corresponding C
structures.

The @code{false} directives denotes that some values of embedded C
pointer should be treated as scheme @code{#f} value. The
@var{<value-list>} is the list of such values. If the @var{<value-list>}
is an empty list, then a C NULL pointer will be treated as scheme
@code{#f}.

The @code{free}, @code{copy}, @code{size} and @code{conversion}
directives are for compatibility with @code{guile-gtk} and currently do
nothing.

@end deffn

@deffn {cgen directive} define-static @var{name} @var{expr}

The @code{define-static} directive is a convenient equivalent of Scheme
@code{define} directive except that the defined name is explicitly
declared as @code{static} in Bigloo @code{module} section.

@end deffn

@deffn {cgen directive} import @var{filename}

The @code{import} directive processes the contents of file pointed by
@var{filename}. The file imported may be any valid Bigloo scheme
text. If the Bigloo @code{module} directive is encountered, then its
contents is appended to output @code{module} section.

All other expressions are processed as if they were included literally
into the file containing this @code{import} directive.

@end deffn

@deffn {cgen directive} @@if @var{condition}
@deffnx {cgen directive} @@endif
@deffnx {cgen directive} @@else

The @code{@@if} is an equivalent of C preprocessor @code{#if}
directive. All subsequent cgen directives untill matching @code{@@endif}
directive are processed only if the @var{condition} is met. The same
directives are recognized by @code{cgen} within any list in any
particular @code{cgen} directive.

For example, to compile the @code{gtk_window_get_title} function only
if the version of GTK library is greater than 1.3:

@example
@@if (string>? gtk-version "1.3")
(define-func gtk_window_get_title
  string
  ((GtkWindow window)))
@@endif
@end example

If an @code{@@else} directive is encountered somewhere between
@code{@@if} and @code{@@endif}, the condition is reversed, for example,
to provide an alternate version of @code{gtk-window-get-title} for older
versions of GTK:

@example
@@if (string>? gtk-version "1.3")

(define-func gtk_window_get_title
  string
  ((GtkWindow window)))

@@else

(define(gtk-window-get-title window::gtk-window)
  (error "gtk-window-get-title"
         "function is not implemented in gtk-1.2"
          window))
@@endif
@end example

It is an error if the @code{@@endif} or @code{@@else} directive is
encountered without a matching @code{@@if} directive within the
list.

Also, it is an error if no @code{@@endif} directive matches the
@code{@@if} directive within the list.

At the moment of writing, this feature is only used to conditionally
compile stuff configured by autoconf.

For example, the @code{gtk-version} variable should be defined using the
@code{-e} option of cgen:

@example
cgen -e "(define gtk-version #t)" @dots{}
@end example

@end deffn

@deffn {cgen directive} module @var{exprs}

The contents of @code{module} directive is appended to @code{module}
section of output @code{cgen} file. Note: this directive is optional,
and it may appear in any part of input @code{cgen} file. More than one
@code{module} directive is allowed.

@end deffn

@deffn {cgen directive} register-predicate!
@end deffn

@deffn {cgen directive} set-current-predicate!
@end deffn

@c ==================================================================
@subsection Usage examples

TBD


