@node    SRFI-1 support, SRFI-13 support, dl, Bigloo Common Library
@section SRFI-1 List Library
@cindex SRFI
@cindex List Library

Bigloo-lib contain realization of list processing library conforming to
SRFI-1 (See @uref{http://srfi.schemers.org/srfi-1/srfi-1.html, SRFI-1:
List Library}). This description built on base of SRFI-1 description.

Some of procedures from SRFI-1 are part of core Bigloo -- @code{cons*},
@code{last-pair}, @code{append!}, @code{reverse!}.

@menu
* Formals::                     
* List Constructors::           
* List Predicates::             
* List Selectors::              
* Misc list functions::         
* list fold/unfold::            
* List filtering::              
* List Searching::              
* Deletions in lists::          
* Association lists::           
* lists as sets::               
@end menu

@node Formals, List Constructors, SRFI-1 support, SRFI-1 support
@subsection Notations used in text

In description of library procedures we will follow this notation:

@table @samp
@item @emph{list} 
A proper (finite, nil-terminated) list

@item @emph{clist} 
A proper or circular list

@item @emph{flist}
A finite (proper or dotted) list

@item @emph{pair} 
A pair

@item @emph{x}, @emph{y}, @emph{d}, @emph{a} 
Any value

@item @emph{object}, @emph{value} 
Any value

@item @emph{n}, @emph{i} 
A natural number (an integer >= 0)

@item @emph{proc} 
A procedure

@item @emph{pred} 
A procedure whose return value is treated as a boolean

@item @emph{=} 
A boolean procedure taking two arguments

@end table


@node List Constructors, List Predicates, Formals, SRFI-1 support
@subsection Constructors

@deffn {procedure} xcons::pair d a

"eXchanged CONS", return pair where @code{car} equal @code{a}, and
@code{cdr} equal @code{d}

@example
(xcons '(b c) 'a) @result{} (a b c)
@end example

@end deffn

@deffn {procedure} make-list::pair-nil n::int #!optional

return @i{n}-element list, whose elements are all the value of optional
argument. If optional argument not given, elements may get arbitrary
values.

@example
(make-list 4 'c) @result{} (c c c c)
@end example

@end deffn

@deffn {procedure} list-tabulate::pair-nil n::int init-proc::procedure

return @i{n}-element list, whose elements are generated by procedure
@code{init-proc}, called with index of element as argument.

@example
(list-tabulate 4 values) @result{} (0 1 2 3)
@end example

@end deffn

@deffn {procedure} list-copy::pair-nil ::pair-nil

Copies given list.

@end deffn

@deffn {procedure} circular-list::pair val1 . vals

Constructs circular list from given values.

@example
(circular-list 'z 'q) @result{} (z q z q z q ...)
@end example

@end deffn

@deffn {procedure} iota count::int #!optional start step

Constructs list containing elements @code{(start start+step
... start+(count-1)*step)}, default value of @code{start} equal 0, and
@code{step} equal 1.

@example
(iota 5) @result{} (0 1 2 3 4)
(iota 5 0 -0.1) @result{} (0 -0.1 -0.2 -0.3 -0.4)
@end example

@end deffn

@node List Predicates, List Selectors, List Constructors, SRFI-1 support
@subsection Predicates

@deffn {procedure} proper-list?::bool x

Return true if @code{x} is a proper list -- finite, nil-terminated list.

@end deffn

@deffn {procedure} dotted-list?::bool x

Return true if @code{x} is a finite, non-nil-terminated list.

@end deffn

@deffn {procedure} circular-list?::bool x

Return true if @code{x} is a circular list.

@end deffn

@deffn {procedure} not-pair?::bool x

Returns true if argument @code{x} is not pair.

@end deffn

@deffn {procedure} null-list?::bool list

@code{List} is a proper or circular list. This procedure returns true if
the argument is the empty list (), and false otherwise. It is an error
to pass this procedure a value which is not a proper or circular list.

@end deffn

@deffn {procedure} list= elt=::procedure . lists

Determines list equality, given an element-equality procedure. 

@end deffn

@node List Selectors, Misc list functions, List Predicates, SRFI-1 support
@subsection Selecting parts of lists

@deffn {procedure} first ::pair
@deffnx {procedure} second ::pair
@deffnx {procedure} third ::pair
@deffnx {procedure} fourth ::pair
@deffnx {procedure} fifth ::pair
@deffnx {procedure} sixth ::pair
@deffnx {procedure} seventh ::pair
@deffnx {procedure} eighth ::pair
@deffnx {procedure} ninth ::pair
@deffnx {procedure} tenth ::pair

Synonyms for car, cadr, caddr, ...

@end deffn

@deffn {procedure} car+cdr x::pair

The fundamental pair deconstructor, that may be presented as
@code{(lambda (p) (values (car p) (cdr p)))}. Return two values.

@end deffn

@deffn {procedure} take::pair-nil x::pair-nil i::int

@code{take} returns the first @i{i} elements of list @code{x}.

@end deffn

@deffn {procedure} take!::pair-nil x::pair-nil i::int

@code{take!} is "linear-update" variant of @code{take}: the procedure
is allowed, but not required, to alter the argument list to produce the
result.  If @code{x} is circular, take! may return a shorter-than-expected list:


@example
(take! (circular-list 1 3 5) 8) @result{} (1 3)
@end example

@end deffn

@deffn {procedure} drop::pair-nil x::pair-nil i::int

@code{drop} returns all but the first @i{i} elements of list @code{x}.

@example
(drop '(a b c d e)  2) @result{} (c d e)
@end example

@end deffn

@deffn {procedure} drop!::pair-nil x::pair-nil i::int

@end deffn

@deffn {procedure} take-right::pair-nil x::pair-nil i::int

@code{take-right} returns the last @i{i} elements of @code{x}.  The
returned list may share a common tail with the argument list. @code{x}
may be any finite list, either proper or dotted

@example
(take-right '(a b c d e) 2) @result{} (d e)
@end example

@end deffn

@deffn {procedure} drop-right::pair-nil x::pair-nil i::int

@code{drop-right} returns all but the last @i{i} elements of @code{x}.

@example
(drop-right '(a b c d e) 2) @result{} (a b c)
@end example

@end deffn

@deffn {procedure} drop-right!::pair-nil x::pair-nil 

@code{drop-right!} is "linear-update" variant of @code{drop-right}: the
procedure is allowed, but not required, to alter the argument list to
produce the result.

@end deffn

@deffn {procedure} split-at x i

@code{split-at} splits the list @code{x} at index @i{i}, returning a
list of the first @i{i} elements, and the remaining tail. It is equivalent
to @code{(values (take x i) (drop x i))}

@example
(split-at '(a b c d e f g h) 3) @result{}
        (a b c)
        (d e f g h)
@end example


@end deffn

@deffn {procedure} split-at! x i

@code{split-at!} is the linear-update variant of @code{split-at}. It is
allowed, but not required, to alter the argument list to produce the
result.

@end deffn

@deffn {procedure} last x::pair-nil

@code{last} returns the last element of the non-empty, finite list @code{x}. 

@example
(last '(a b c)) @result{} c
@end example

@end deffn

@node Misc list functions, list fold/unfold, List Selectors, SRFI-1 support
@subsection Miscellaneous

@deffn {procedure} length+ x

@code{lenght+}, like @code{length}, return the length of the argument,
but when it applied to circular list, this function return @code{#f}.

@example
(length+ '(1 2 3 4)) @result{} 4
(length+ (circular-list '1 '2)) @result{} #f
@end example

@end deffn

@deffn {procedure} concatenate::pair-nil lists::pair-nil
@deffnx {procedure} concatenate!::pair-nil  lists::pair-nil

These functions append the elements of their argument together. Argument
@code{lists} is list of list. @code{concatenate!} is the linear-update
variant, defined in terms of @code{append!} instead of @code{append}.

@example
(concatenate '((1 2) (3 4))) @result{} (1 2 3 4)
@end example

@end deffn

@deffn {procedure} append-reverse rev-head::pair-nil tail
@deffnx {procedure} append-reverse! rev-head::pair-nil tail

@code{append-reverse} returns @code{(append (reverse rev-head)
tail)}. @code{append-reverse!} is just the linear-update variant -- it
is allowed, but not required, to alter rev-head's cons cells to
construct the result.

@example
(append-reverse '(1 2 3) '(4 5 6)) @result{} (3 2 1 4 5 6)
@end example

@end deffn

@deffn {procedure} zip::pair-nil ::pair-nil . more-list

If @code{zip} is passed @i{n} lists, it returns a list as long as the
shortest of these lists, each element of which is an @i{n}-element list
comprised of the corresponding elements from the parameter lists.  At
least one of the argument lists must be finite.

@example
(zip '(one two three) 
     '(1 2 3)
     '(odd even odd even odd even odd even))
    @result{} ((one 1 odd) (two 2 even) (three 3 odd))

(zip '(1 2 3)) @result{} ((1) (2) (3))

(zip '(3 1 4 1) (circular-list #f #t)) 
    @result{} ((3 #f) (1 #t) (4 #f) (1 #t))
@end example

@end deffn

@deffn {procedure} unzip1::pair-nil lis::pair-nil
@deffnx {procedure} unzip2 ::pair-nil
@deffnx {procedure} unzip3 ::pair-nil
@deffnx {procedure} unzip4 ::pair-nil
@deffnx {procedure} unzip5 ::pair-nil

@code{unzip1} takes a list of lists, where every list must contain at
least one element, and returns a list containing the initial element of
each such list. That is, it returns @code{(map car lists)}. 
@code{unzip2} takes a list of lists, where every list must
contain at least two elements, and returns two values: a list of the
first elements, and a list of the second elements. @code{unzip3} does
the same for the first three elements of the lists, and so forth.

@example
(unzip2 '((1 one) (2 two) (3 three))) @result{}
    (1 2 3) 
    (one two three)
@end example

@end deffn

@deffn {procedure} count::int pred::procedure list1::pair-nil . lists

@code{pred} is a procedure taking as many arguments as there are lists
and returning a single value. It is applied element-wise to the elements
of the lists, and a count is tallied of the number of elements that
produce a true value. This count is returned. count is "iterative" in
that it is guaranteed to apply @code{pred} to the list elements in a
left-to-right order. The counting stops when the shortest list expires.
At least one of the argument lists must be finite.

@example
(count even? '(3 1 4 1 5 9 2 5 6)) @result{} 3
(count < '(1 2 4 8) '(2 4 6 8 10 12 14 16)) @result{} 3
(count < '(3 1 4 1) (circular-list 1 10)) @result{} 2
@end example

@end deffn

@node list fold/unfold, List filtering, Misc list functions, SRFI-1 support
@subsection Fold, unfold & map

@deffn {procedure} fold kons::procedure knil lis1::pair-nil . lists

The fundamental list iterator.

When we use only one list @code{lis1=(e1 e2 ... en)}, then fold perform
@code{(kons en ... (kons e2 (kons e1 knil)) ... )}. For example,

@example
(fold + 0 lis) @result{} sum elements of lis
(fold cons '() lis) @result{} reverse lis
(fold (lambda (x count) 
      (if (symbol? x) (+ count 1) count)) 0 lis) @result{}
                count symbols in lis
@end example

If @i{n} list arguments are provided, then the kons function must take
@i{n+1} parameters: one element from each list, and the "seed" or fold
state, which is initially @code{knil}. The fold operation terminates
when the shortest list runs out of values. At least one of the list
arguments must be finite.

@example
(fold cons* '() '(a b c) '(1 2 3 4 5)) @result{} (c 3 b 2 a 1)
@end example

@end deffn

@deffn {procedure} fold-right kons::procedure knil lis1::pair-nil . lists

The fundamental list iterator. Like @code{fold}, but perform iteration
from another side of lists.

When we use only one list @code{lis1=(e1 e2 ... en)}, then fold perform
@code{(kons e1 (kons e2 ... (kons en knil)))}. For example,

@example
(fold-right cons '() lis) @result{} copy lis
(fold-right (lambda (x l) 
        (if (even? x) (cons x l) l)) '() lis)) @result{}
                Filter the even numbers out of lis.
@end example

If @i{n} list arguments are provided, then the kons function must take
@i{n+1} parameters: one element from each list, and the "seed" or fold
state, which is initially @code{knil}. The fold operation terminates
when the shortest list runs out of values. At least one of the list
arguments must be finite.

@example
(fold-right cons* '() '(a b c) '(1 2 3 4 5)) @result{} (a 1 b 2 c 3)
@end example


@end deffn

@deffn {procedure} pair-fold f::procedure zero lis1::pair-nil . lists

Analogous to @code{fold}, but @code{kons} is applied to successive
sublists of the lists, rather than successive elements@w{--} that is,
@code{kons} is applied to the pairs making up the lists, giving this
(tail) recursion. For finite lists, the @code{kons} function may
reliably apply @code{set-cdr!} to the pairs it is given without altering
the sequence of execution. At least one of the list arguments must be
finite.

@example
(pair-fold (lambda (pair tail) 
                (set-cdr! pair tail) pair) '() lis)) @result{}
                        Destructively reverse a list
@end example


@end deffn

@deffn {procedure} pair-fold-right f::procedure zero lis1::pair-nil . lists

Holds the same relationship with @code{fold-right} that @code{pair-fold}
holds with @code{fold}. Obeys the recursion. At least one of the list
arguments must be finite.

@example
(pair-fold-right cons '() '(a b c)) @result{} ((a b c) (b c) (c))
@end example

@end deffn

@deffn {procedure} reduce f::procedure ridentity lis::pair-nil

@code{reduce} is a variant of @code{fold}.

@code{ridentity} should be a "right identity" of the procedure
@code{f}@w{--} that is, for any value @code{x} acceptable to @code{f},
@code{(f x ridentity) = x}. 

@code{reduce} has the following definition: @i{If @code{list} = (),
return @code{ridentity}; Otherwise, return @code{(fold f (car list) (cdr
list))}}. In other words, we compute @code{(fold f ridentity list)}.

Note that @code{ridentity} is used only in the empty-list case. You
typically use reduce when applying @code{f} is expensive and you'd like
to avoid the extra application incurred when fold applies @code{f} to
the head of list and the identity value, redundantly producing the same
value passed in to @code{f}. For example, if @code{f} involves searching
a file directory or performing a database query, this can be
significant. In general, however, @code{fold} is useful in many contexts
where @code{reduce} is not (consider the examples given in the
@code{fold} definition@w{--} only one of the five folds uses a function
with a right identity. The other four may not be performed with
@code{reduce}).

@example
(reduce max 0 nums) @result{}
        Take the max of a list of non-negative integers.
@end example

@end deffn

@deffn {procedure} reduce-right f::procedure ridentity lis::pair-nil

@code{reduce-right} is the @code{fold-right} variant of
@code{reduce}. In other words, we compute @code{(fold-right f ridentity
list)}.

@example
(reduce-right append '() list-of-lists) @result{} 
        Append a bunch of lists together
@end example

@end deffn

@deffn {procedure} unfold p::procedure f::procedure g::procedure seed #!optional

@code{unfold} is best described by its basic recursion:
@example
        (unfold p f g seed) = 
            (if (p seed) (tail-gen seed)
                (cons (f seed)
                      (unfold p f g (g seed))))
@end example

@noindent where
@table @code
@item p
Determines when to stop unfolding. 

@item f
Maps each seed value to the corresponding list element. 

@item g
Maps each seed value to next seed value. 

@item seed
The "state" value for the unfold. 

@item tail-gen
Creates the tail of the list; defaults to @code{(lambda (x) '())}
@end table

In other words, we use @code{g} to generate a sequence of seed values
@code{seed, g(seed), g^2(seed), g^3(seed), ...}. These seed values are
mapped to list elements by @code{f}, producing the elements of the
result list in a left-to-right order. @code{P} says when to stop.

@code{unfold} is the fundamental recursive list constructor, just as
@code{fold-right} is the fundamental recursive list consumer. While
@code{unfold} may seem a bit abstract to novice functional programmers,
it can be used in a number of ways:

@example
(unfold (lambda (x) (> x 10))
        (lambda (x) (* x x))
	(lambda (x) (+ x 1))
	1) @result{} List of squares: 1^2 ... 10^2

(unfold null-list? car cdr lis) @result{} Copy a proper list.

(unfold not-pair? car cdr lis values) @result{} Copy a possibly non-proper list
@end example

@end deffn

@deffn {procedure} unfold-right p::procedure f::procedure g::procedure seed #!optional

@code{unfold-right} is the fundamental iterative list constructor, just
as @code{fold} is the fundamental iterative list consumer. This function
like @code{unfold}, but @code{unfold-right} constructs a list with the
following loop:

@example
(let lp ((seed seed) (lis tail))
  (if (p seed) lis
      (lp (g seed)
          (cons (f seed) lis))))
@end example

@noindent where
@table @code
@item p
Determines when to stop unfolding. 

@item f
Maps each seed value to the corresponding list element. 

@item g
Maps each seed value to next seed value. 

@item seed
The "state" value for the unfold. 

@item tail
list terminator; defaults to @code{'()}.
@end table

In other words, we use @code{g} to generate a sequence of seed values
@code{seed, g(seed), g^2(seed), g^3(seed), ...}. These seed values are
mapped to list elements by @code{f}, producing the elements of the
result list in a right-to-left order. @code{P} says when to stop.

@example
(unfold-right zero? 
              (lambda (x) (* x x))
              (lambda (x) (- x 1))
              10) @result{} List of squares: 1^2 ... 10^2

(unfold-right null-list? car cdr lis) @result{} Reverse a proper list
@end example

@end deffn

@deffn {procedure} append-map::pair-nil f::procedure lis1::pair-nil . lists
@deffnx {procedure} append-map!::pair-nil f::procedure lis1::pair-nil . lists

Equivalent to @code{(apply append (map f clist1 clist2 ...))} and
@code{(apply append! (map f clist1 clist2 ...))}.  Map @code{f} over the
elements of the lists, just as in the @code{map} function. However, the
results of the applications are appended together to make the final
result. @code{append-map} uses @code{append} to append the results
together; @code{append-map!} uses @code{append!}. At least one of the
list arguments must be finite.

@example
(append-map! (lambda (x) (list x (- x))) '(1 3 8)) @result{} (1 -1 3 -3 8 -8)
@end example
x
@end deffn

@deffn {procedure} map!::pair-nil f::procedure lis1::pair-nil . lists

Linear-update variant of @code{map} -- @code{map!} is allowed, but not
required, to alter the cons cells of lis1 to construct the result list.

The dynamic order in which the various applications of @code{f} are made
is not specified. In the @i{n}-ary case, lists must have at least as
many elements as lis1.

@end deffn

@deffn {procedure} map-in-order::pair-nil f::procedure lis1::pair-nil . lists

A variant of the @code{map} procedure that guarantees to apply @code{f}
across the elements of the lists arguments in a left-to-right
order. This is useful for mapping procedures that both have side effects
and return useful values. At least one of the list arguments must be
finite.

@end deffn

@deffn {procedure} pair-for-each proc::procedure lis1::pair-nil . lists

Like @code{for-each}, but @code{f} is applied to successive sublists of
the argument lists. That is, @code{f} is applied to the cons cells of
the lists, rather than the lists' elements. These applications occur in
left-to-right order.

The @code{f} procedure may reliably apply @code{set-cdr!} to the pairs
it is given without altering the sequence of execution.

@example
(pair-for-each (lambda (pair) (display pair) (newline)) '(a b c)) @result{}
        (a b c)
        (b c)
        (c)
        #f
@end example

@end deffn

@deffn {procedure} filter-map::pair-nil f::procedure lis1::pair-nil . lists

Like @code{map}, but only true values are saved. The dynamic order in
which the various applications of @code{f} are made is not specified. At
least one of the list arguments must be finite.

@example
(filter-map (lambda (x) (and (number? x) (* x x))) '(a 1 b 3 c 7)) @result{}
        (1 9 49)
@end example

@end deffn

@node List filtering, List Searching, list fold/unfold, SRFI-1 support
@subsection Filtering & partitioning

@deffn {procedure} filter::pair-nil pred::procedure list::pair-nil

Return all the elements of list that satisfy predicate @code{pred}. The
list is not disordered -- elements that appear in the result list occur
in the same order as they occur in the argument list. The returned list
may share a common tail with the argument list. The dynamic order in
which the various applications of pred are made is not specified.

@example
(filter even? '(0 7 8 8 43 -4)) @result{} (0 8 8 -4)
@end example

@end deffn

@deffn {procedure} partition pred::procedure lis::pair-nil

Partitions the elements of list with predicate @code{pred}, and returns
two values: the list of in-elements and the list of out-elements. The
list is not disordered -- elements occur in the result lists in the same
order as they occur in the argument list. The dynamic order in which the
various applications of pred are made is not specified. One of the
returned lists may share a common tail with the argument list.

@example
(partition symbol? '(one 2 3 four five 6)) @result{} 
        (one four five)
        (2 3 6)
@end example

@end deffn

@deffn {procedure} remove::pair-nil ::procedure lis::pair-nil

Returns list without the elements that satisfy predicate @code{pred}:
@code{(lambda (pred list) (filter (lambda (x) (not (pred x))) list))}.
The list is not disordered -- elements that appear in the result list
occur in the same order as they occur in the argument list. The returned
list may share a common tail with the argument list. The dynamic order
in which the various applications of pred are made is not specified.

@example
(remove even? '(0 7 8 8 43 -4)) @result{} (7 43)
@end example

@end deffn

@deffn {procedure} filter!::pair-nil pred::procedure lis::pair-nil
@deffnx {procedure} partition! pred::procedure lis::pair-nil
@deffnx {procedure} remove!::pair-nil ::procedure lis::pair-nil

Linear-update variants of @code{filter}, @code{partition} and
@code{remove}. These procedures are allowed, but not required, to alter
the cons cells in the argument list to construct the result lists.

@end deffn

@node List Searching, Deletions in lists, List filtering, SRFI-1 support
@subsection Searching

The following procedures all search lists for a leftmost element
satisfying some criteria. This means they do not always examine the
entire list; thus, there is no efficient way for them to reliably detect
and signal an error when passed a dotted or circular list.


@deffn {procedure} find pred::procedure clist::pair-nil

Return the first element of @code{clist} that satisfies predicate
@code{pred}; false if no element does.

@example
(find even? '(1 2 3))	@result{} 2
(find even? '(1 7 3))	@result{} #f
(find even? '(1 3 . x))	@result{} error
(find even? '(1 2 . x))	@result{} error/undefined
(find even? (circular-list 1 6 3)) @result{} 6
(find even? (circular-list 1 3)) @result{} error
@end example

@end deffn

@deffn {procedure} find-tail pred::procedure lis::pair-nil

Return the first pair of @code{clist} whose car satisfies
@code{pred}. If no pair does, return false. @code{find-tail} can be
viewed as a general-predicate variant of the @code{member} function. In
the circular-list case, this procedure "rotates" the list.

@example
(find-tail even? '(3 1 37 -8 -5 0 0)) @result{} (-8 -5 0 0)
(find-tail even? '(3 1 37 -5)) @result{} #f
@end example

@end deffn

@deffn {procedure} take-while::pair-nil pred::procedure clist::pair-nil
@deffnx {procedure} take-while!::pair-nil pred::procedure clist::pair-nil

Returns the longest initial prefix of @code{clist} whose elements all
satisfy the predicate @code{pred}. @code{Take-while!} is the
linear-update variant. It is allowed, but not required, to alter the
argument list to produce the result.

@example
(take-while even? '(2 18 3 10 22 9)) @result{} (2 18)
@end example

@end deffn

@deffn {procedure} drop-while::pair-nil pred::procedure clist::pair-nil

Drops the longest initial prefix of clist whose elements all satisfy the
predicate @code{pred}, and returns the rest of the list.

@example
(drop-while even? '(2 18 3 10 22 9)) @result{} (3 10 22 9)
@end example

@end deffn

@deffn {procedure} span pred::procedure lis::pair-nil
@deffnx {procedure} span! pred::procedure lis::pair-nil
@deffnx {procedure} break  pred::procedure lis::pair-nil
@deffnx {procedure} break! pred::procedure lis::pair-nil

@code{Span} splits the list into the longest initial prefix whose
elements all satisfy @code{pred}, and the remaining tail. @code{Break}
inverts the sense of the predicate: the tail commences with the first
element of the input list that satisfies the predicate.

In other words: @code{span} finds the intial span of elements satisfying
@code{pred}, and @code{break} breaks the list at the first element
satisfying pred. @code{Span!}  and @code{break!} are the linear-update
variants. They are allowed, but not required, to alter the argument list
to produce the result.

@example
(span even? '(2 18 3 10 22 9)) @result{}
        (2 18)
        (3 10 22 9)

(break even? '(3 1 4 1 5 9)) @result{}
        (3 1)
        4 1 5 9)
@end example


@end deffn

@deffn {procedure} any pred::procedure clist1::pair-nil . clists

Applies the predicate across the lists, returning true if the predicate
returns true on any application. If there are @i{n} list arguments
@code{clist1 ... clistn}, then @code{pred} must be a procedure taking
@i{n} arguments and returning a boolean result.

@example
(any integer? '(a 3 b 2.7))   @result{} #t
(any integer? '(a 3.1 b 2.7)) @result{} #f
(any < '(3 1 4 1 5) '(2 7 1 8 2)) @result{} #t
@end example

@end deffn

@deffn {procedure} every pred::procedure clist1::pair-nil . clists

Applies the predicate across the lists, returning true if the predicate
returns true on every application. If there are @i{n} list arguments
@code{clist1 ... clistn}, then @code{pred} must be a procedure taking
@code{n} arguments and returning a boolean result. If one of the clisti
has no elements, @code{every} simply returns @code{#t}.

@example
(every even? '(2 4 5 6)) @result{} #f
(every even? '(2 4 6 8)) @result{} #t
@end example

@end deffn

@deffn {procedure} list-index pred::procedure clist1::pair-nil . lists

Return the index of the leftmost element that satisfies @code{pred}. If
there are @i{n} list arguments @code{clist1 ... clistn}, then
@code{pred} must be a function taking @code{n} arguments and returning a
boolean result. The iteration stops when one of the lists runs out of
values; in this case, @code{list-index} returns @code{#f}.

@example
(list-index even? '(3 1 4 1 5 9)) @result{} 2
(list-index < '(3 1 4 1 5 9 2 5 6) '(2 7 1 8 2)) @result{} 1
(list-index = '(3 1 4 1 5 9 2 5 6) '(2 7 1 8 2)) @result{} #f
@end example

@end deffn

@deffn {procedure} member x lis::pair-nil #!optional =

@code{member} is extended from its R5RS definition to allow the client
to pass in an optional equality procedure @code{=} used to compare keys.

@example
(member (list 'a) '(b (a) c)) @result{} ((a) c)
@end example

@end deffn


@node Deletions in lists, Association lists, List Searching, SRFI-1 support
@subsection Deletion in list

@deffn {procedure} delete::pair-nil x list::pair-nil #!optional =::proc
@deffnx {procedure} delete!::pair-nil x list::pair-nil #!optional =::proc

@code{delete} uses the optional comparison procedure @code{=}, which
defaults to @code{equal?}, to find all elements of list that are equal
to @code{x}, and deletes them from list. The dynamic order in which the
various applications of @code{=} are made is not specified. The list is
not disordered -- elements that appear in the result list occur in the
same order as they occur in the argument list. The result may share a
common tail with the argument list.  @code{delete!} is the linear-update
variant of @code{delete}. It is allowed, but not required, to alter the
cons cells in its argument list to construct the result.

@example
(delete 5 '(1 5 11 3 14 8) < ) @result{} (1 5 3)
@end example

@end deffn

@deffn {procedure} delete-duplicates::pair-nil list::pair-nil #!optional =::proc
@deffnx {procedure} delete-duplicates!::pair-nil list::pair-nil #!optional =::proc

@code{delete-duplicates} removes duplicate elements from the @code{list}
argument. If there are multiple equal elements in the argument
@code{list}, the result list only contains the first or leftmost of
these elements in the result. The order of these surviving elements is
the same as in the original list -- delete-duplicates does not disorder
the list (hence it is useful for "cleaning up" association lists).

The @code{=} parameter is used to compare the elements of the list; it
defaults to @code{equal?}. If @code{x} comes before @code{y} in list,
then the comparison is performed @code{(= x y)}. The comparison
procedure will be used to compare each pair of elements in list no more
than once; the order in which it is applied to the various pairs is not
specified.  @code{delete-duplicates!} is the linear-update variant of
@code{delete-duplicates}; it is allowed, but not required, to alter the
cons cells in its argument list to construct the result.

@example
(delete-duplicates '(a b a c a b c z)) @result{} (a b c z)
(delete-duplicates '((a . 3) (b . 7) (a . 9) (c . 1))
                   (lambda (x y) (eq? (car x) (car y))))
    @result{} ((a . 3) (b . 7) (c . 1))
@end example

@end deffn


@node Association lists, lists as sets, Deletions in lists, SRFI-1 support
@subsection Association lists

An "association list" (or "alist") is a list of pairs. The car of each
pair contains a key value, and the cdr contains the associated data
value. They can be used to construct simple look-up tables in
Scheme. Note that association lists are probably inappropriate for
performance-critical use on large data; in these cases, hash tables or
some other alternative should be employed.

@deffn {procedure} assoc x list::pair-nil #!optional =::proc

@code{assoc} is extended from its R5RS definition to allow the client to
pass in an optional equality procedure @code{=} used to compare keys.
The comparison procedure is used to compare the elements @code{ei} of
@code{list} to the key parameter @code{x} in this way: @code{(= key (car
ei)) ; list is (E1 ... En)} That is, the first argument is always key,
and the second argument is one of the list elements.

@example
(define e '((a 1) (b 2) (c 3)))
(assoc (list 'a) '(((a)) ((b)) ((c)))) @result{} ((a))
@end example

@end deffn

@deffn {procedure} alist-cons::pair key datum alist::pair-nil

Cons a new alist entry mapping @code{key}->@code{datum}onto @code{alist}
This function may be presented as @code{(lambda (key datum alist) (cons
(cons key datum) alist))}.

@example
(define e '((a 1) (b 2) (c 3)))
(alist-cons 'd 10 e) @result{} ((d . 10) (a 1) (b 2) (c 3))
@end example

@end deffn

@deffn {procedure} alist-copy::pair-nil alist::pair-nil

Make a fresh copy of @code{alist} This means copying each pair that forms an
association as well as the spine of the list, i.e. @code{(lambda (a)
(map (lambda (elt) (cons (car elt) (cdr elt))) a))}.

@end deffn

@deffn {procedure} alist-delete::pair-nil key alist::pair-nil #!optional =::proc
@deffnx {procedure} alist-delete!::pair-nil key alist::pair-nil #!optional =::proc

@code{alist-delete} deletes all associations from @code{alist} with the
given key, using key-comparison procedure @code{=}, which defaults to
@code{equal?}. The dynamic order in which the various applications of
@code{=} are made is not specified. @code{alist-delete!} is the
linear-update variant of @code{alist-delete}. It is allowed, but not
required, to alter cons cells from the alist parameter to construct the
result.

@example
(define e '((a 1) (b 2) (c 3) (d 10)))
(alist-delete 'd e) @result{} ((a 1) (b 2) (c 3))
@end example

@end deffn


@node lists as sets,  , Association lists, SRFI-1 support
@subsection Set operations on lists

These procedures implement operations on sets represented as lists of
elements. They all take an @code{=} argument used to compare elements of
lists. This equality procedure is required to be consistent with
@code{eq?}. That is, it must be the case that @code{(eq? x y)} =>
@code{(= x y)}.

@deffn {procedure} lset<= elt=::procedure . lists

Returns true iff every listi is a subset of listi+1, using @code{elt=}
for the element-equality procedure. List A is a subset of list B if
every element in A is equal to some element of B. When performing an
element comparison, the @code{elt=} procedure's first argument is an
element of A; its second, an element of B.

@example
(lset<= eq? '(a) '(a b a) '(a b c c)) @result{} #t
@end example

@end deffn

@deffn {procedure} lset= elt=::procedure . lists

Returns true iff every listi in lists is set-equal to listi+1, using
@code{elt=} for the element-equality procedure. "Set-equal" simply means
that listi is a subset of listi+1, and listi+1 is a subset of listi. The
@code{elt=} procedure's first argument is an element of listi; its
second is an element of listi+1.

@example
(lset= eq? '(b e a) '(a e b) '(e e b a)) @result{} #t
@end example

@end deffn

@deffn {procedure} lset-adjoin::pair-nil =::procedure list::pair-nil . elts

Adds the elti elements not already in the @code{list} parameter to the
result list. The result shares a common tail with the list
parameter. The new elements are added to the front of the list, but no
guarantees are made about their order. The @code{=} parameter is an
equality procedure used to determine if an elti is already a member of
list. Its first argument is an element of list; its second is one of the
elti.

@example
(lset-adjoin eq? '(a b c d c e) 'a 'e 'i 'o 'u) @result{} (u o i a b c d c e)
@end example

@end deffn

@deffn {procedure} lset-union::pair-nil elt=::procedure . lists

Returns the union of the lists, using @code{elt=} for the
element-equality procedure.

@example
(lset-union eq? '(a b c d e) '(a e i o u)) @result{} (u o i a b c d e)
(lset-union eq? '(a a c) '(x a x)) @result{} (x a a c)
@end example

@end deffn

@deffn {procedure} lset-intersection::pair-nil elt=::procedure list1::pair-nil . lists

Returns the intersection of the lists, using @code{elt=} for the
element-equality procedure.

The intersection of lists A and B is comprised of every element of A
that is @code{elt=} to some element of B: @code{(elt= a b)}, for a in A,
and b in B. Note this implies that an element which appears in B and
multiple times in list A will also appear multiple times in the result.

The order in which elements appear in the result is the same as they
appear in @code{list1}@w{--} that is, lset-intersection essentially
filters @code{list1}, without disarranging element order. The result may
share a common tail with @code{list1}.

@end deffn

@deffn {procedure} lset-difference::pair-nil elt=::procedure list1::pair-nil . lists

Returns the difference of the lists, using @code{elt=} for the
element-equality procedure -- all the elements of @code{list1} that are not
@code{elt=} to any element from one of the other @code{listi} parameters.

The @code{elt=} procedure's first argument is always an element of
@code{list1}; its second is an element of one of the other
@code{listi}. Elements that are repeated multiple times in the
@code{list1} parameter will occur multiple times in the result.

@example
(lset-difference eq? '(a b c d e) '(a e i o u)) @result{} (b c d)
(lset-difference eq? '(a b c)) @result{} (a b c)
@end example

@end deffn

@deffn {procedure} lset-xor::pair-nil elt=::procedure . lists

Returns the exclusive-or of the sets, using @code{=} for the
element-equality procedure. If there are exactly two lists, this is all
the elements that appear in exactly one of the two lists. The operation
is associative, and thus extends to the @i{n}-ary case -- the elements
that appear in an odd number of the lists. The result may share a common
tail with any of the listi parameters.

@example
(lset-xor eq? '(a b c d e) '(a e i o u)) @result{} (d c b i o u)
(lset-xor eq? '(a b c d e)) @result{} (a b c d e)
@end example

@end deffn

@deffn {procedure} lset-diff+intersection elt=::procedure list1::pair-nil . lists

Returns two values -- the difference and the intersection of the lists.
The @code{elt=} procedure's first argument is an element of
@code{list1}; its second is an element of one of the other
@code{listi}. Either of the answer lists may share a common tail with
@code{list1}. This operation essentially partitions @code{list1}.

@end deffn

@deffn {procedure} lset-union!::pair-nil elt=::procedure . lists
@deffnx {procedure} lset-intersection!::pair-nil elt=::procedure lis1::pair-nil . lists
@deffnx {procedure} lset-difference!::pair-nil elt=::procedure lis1::pair-nil . lists
@deffnx {procedure} lset-xor!::pair-nil elt=::procedure . lists
@deffnx {procedure} lset-diff+intersection! elt=::procedure lis1::pair-nil . lists

These are linear-update variants. They are allowed, but not required, to
use the cons cells in their first list parameter to construct their
answer. @code{lset-union!} is permitted to recycle cons cells from any
of its list arguments.

@end deffn


